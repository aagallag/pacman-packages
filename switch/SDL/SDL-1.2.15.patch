diff --git a/build-scripts/config.guess b/build-scripts/config.guess
index e792aac60..1f5c50c0d 100755
--- a/build-scripts/config.guess
+++ b/build-scripts/config.guess
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-#   Free Software Foundation, Inc.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
 
-timestamp='2009-09-18'
+timestamp='2014-03-23'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,26 +15,22 @@ timestamp='2009-09-18'
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner.
 #
 # You can get the latest version of this script from:
 # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+#
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -56,8 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright 1992-2014 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -139,12 +132,33 @@ UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -180,7 +194,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		fi
 		;;
 	    *)
-	        os=netbsd
+		os=netbsd
 		;;
 	esac
 	# The OS release
@@ -201,6 +215,10 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
 	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
+	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
@@ -223,7 +241,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 		;;
 	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
@@ -269,7 +287,10 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
@@ -295,12 +316,12 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	echo s390-ibm-zvmoe
 	exit ;;
     *:OS400:*:*)
-        echo powerpc-ibm-os400
+	echo powerpc-ibm-os400
 	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -333,6 +354,9 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux${UNAME_RELEASE}
+	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
 	SUN_ARCH="i386"
@@ -391,23 +415,23 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint${UNAME_RELEASE}
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
+	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint${UNAME_RELEASE}
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-milan-mint${UNAME_RELEASE}
+	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-hades-mint${UNAME_RELEASE}
+	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-unknown-mint${UNAME_RELEASE}
+	exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten${UNAME_RELEASE}
 	exit ;;
@@ -477,8 +501,8 @@ EOF
 	echo m88k-motorola-sysv3
 	exit ;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
 	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
@@ -491,7 +515,7 @@ EOF
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit ;;
+	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
 	exit ;;
@@ -548,7 +572,7 @@ EOF
 		echo rs6000-ibm-aix3.2
 	fi
 	exit ;;
-    *:AIX:*:[456])
+    *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
@@ -591,52 +615,52 @@ EOF
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case "${sc_cpu_version}" in
+		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case "${sc_kernel_bits}" in
+			  32) HP_ARCH="hppa2.0n" ;;
+			  64) HP_ARCH="hppa2.0w" ;;
 			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
+			esac ;;
+		    esac
 		fi
 		if [ "${HP_ARCH}" = "" ]; then
 		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
+		    sed 's/^		//' << EOF >$dummy.c
 
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
 
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
 
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
@@ -727,22 +751,22 @@ EOF
 	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit ;;
+	exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit ;;
+	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit ;;
+	exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit ;;
+	exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit ;;
+	exit ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
@@ -766,14 +790,14 @@ EOF
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
@@ -785,34 +809,39 @@ EOF
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit ;;
     *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case ${UNAME_PROCESSOR} in
 	    amd64)
 		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
 	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
 	esac
 	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
+    *:MSYS*:*)
+	echo ${UNAME_MACHINE}-pc-msys
+	exit ;;
     i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
+	# uname -m includes "-pc" on this system.
+	echo ${UNAME_MACHINE}-mingw32
 	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit ;;
-    *:Interix*:[3456]*)
-    	case ${UNAME_MACHINE} in
+    *:Interix*:*)
+	case ${UNAME_MACHINE} in
 	    x86)
 		echo i586-pc-interix${UNAME_RELEASE}
 		exit ;;
-	    EM64T | authenticamd | genuineintel)
+	    authenticamd | genuineintel | EM64T)
 		echo x86_64-unknown-interix${UNAME_RELEASE}
 		exit ;;
 	    IA64)
@@ -845,15 +874,22 @@ EOF
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
@@ -863,44 +899,56 @@ EOF
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
+	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
-	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
+	    else
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
+	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    hexagon:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	echo ${UNAME_MACHINE}-pc-linux-gnu
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -918,56 +966,64 @@ EOF
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    tile*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -976,11 +1032,11 @@ EOF
 	echo i386-sequent-sysv4
 	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
+	# Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
 	exit ;;
     i*86:OS/2:*:*)
@@ -1012,7 +1068,7 @@ EOF
 	fi
 	exit ;;
     i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
@@ -1040,13 +1096,13 @@ EOF
 	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i586.
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
 	# prints for the "djgpp" host, or else GDB configury will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
-        exit ;;
+	exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
 	exit ;;
@@ -1081,8 +1137,8 @@ EOF
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
     NCR*:*:4.2:* | MPRAS*:*:4.2:*)
 	OS_REL='.3'
 	test -r /etc/.relid \
@@ -1125,10 +1181,10 @@ EOF
 		echo ns32k-sni-sysv
 	fi
 	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit ;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
@@ -1154,11 +1210,11 @@ EOF
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv${UNAME_RELEASE}
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit ;;
+	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
 	exit ;;
@@ -1171,6 +1227,9 @@ EOF
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
@@ -1197,19 +1256,31 @@ EOF
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
@@ -1223,7 +1294,10 @@ EOF
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NEO-?:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
@@ -1268,13 +1342,13 @@ EOF
 	echo pdp10-unknown-its
 	exit ;;
     SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
+	echo mips-sei-seiux${UNAME_RELEASE}
 	exit ;;
     *:DragonFly:*:*)
 	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
 	exit ;;
     *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
 	case "${UNAME_MACHINE}" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
@@ -1292,158 +1366,10 @@ EOF
     i*86:AROS:*:*)
 	echo ${UNAME_MACHINE}-pc-aros
 	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+esac
 
 cat >&2 <<EOF
 $0: unable to guess system type
diff --git a/build-scripts/config.sub b/build-scripts/config.sub
index 5ecc18b6a..bba4efb80 100755
--- a/build-scripts/config.sub
+++ b/build-scripts/config.sub
@@ -1,38 +1,31 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
-#   Free Software Foundation, Inc.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
 
-timestamp='2009-10-07'
+timestamp='2014-09-11'
 
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted GNU ChangeLog entry.
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -75,8 +68,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright 1992-2014 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -123,13 +115,18 @@ esac
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
-  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
@@ -152,12 +149,12 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
-        -bluegene*)
-	        os=-cnk
+	-bluegene*)
+		os=-cnk
 		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
@@ -173,10 +170,10 @@ case $os in
 		os=-chorusos
 		basic_machine=$1
 		;;
- 	-chorusrdb)
- 		os=-chorusrdb
+	-chorusrdb)
+		os=-chorusrdb
 		basic_machine=$1
- 		;;
+		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
@@ -221,6 +218,12 @@ case $os in
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
@@ -245,20 +248,28 @@ case $basic_machine in
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
+	| aarch64 | aarch64_be \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| be32 | be64 \
 	| bfin \
-	| c4x | clipper \
+	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
+	| epiphany \
 	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| hexagon \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| k1om \
+	| le32 | le64 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -272,37 +283,51 @@ case $basic_machine in
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
-	| nios | nios2 \
+	| nds32 | nds32le | nds32be \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
-	| rx \
+	| riscv32 | riscv64 \
+	| rl78 | rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
-	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
+	| spu \
+	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| we32k \
-	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
-		# Motorola 68HC11/12.
+	c54x)
+		basic_machine=tic54x-unknown
+		;;
+	c55x)
+		basic_machine=tic55x-unknown
+		;;
+	c6x)
+		basic_machine=tic6x-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
@@ -312,6 +337,21 @@ case $basic_machine in
 		basic_machine=mt-unknown
 		;;
 
+	strongarm | thumb | xscale)
+		basic_machine=arm-unknown
+		;;
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	xscaleeb)
+		basic_machine=armeb-unknown
+		;;
+
+	xscaleel)
+		basic_machine=armel-unknown
+		;;
+
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
@@ -326,25 +366,31 @@ case $basic_machine in
 	# Recognize the basic CPU types with company name.
 	580-* \
 	| a29k-* \
+	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| hexagon-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| k1om-* \
+	| le32-* | le64-* \
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -358,32 +404,41 @@ case $basic_machine in
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
-	| nios-* | nios2-* \
+	| nds32-* | nds32le-* | nds32be-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
+	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
-	| romp-* | rs6000-* | rx-* \
+	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| tahoe-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile*-* \
 	| tron-* \
-	| v850-* | v850e-* | vax-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
 	| ymp-* \
 	| z8k-* | z80-*)
@@ -408,7 +463,7 @@ case $basic_machine in
 		basic_machine=a29k-amd
 		os=-udi
 		;;
-    	abacus)
+	abacus)
 		basic_machine=abacus-unknown
 		;;
 	adobe68k)
@@ -478,11 +533,20 @@ case $basic_machine in
 		basic_machine=powerpc-ibm
 		os=-cnk
 		;;
+	c54x-*)
+		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c55x-*)
+		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c6x-*)
+		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
-        cegcc)
+	cegcc)
 		basic_machine=arm-unknown
 		os=-cegcc
 		;;
@@ -514,7 +578,7 @@ case $basic_machine in
 		basic_machine=craynv-cray
 		os=-unicosmp
 		;;
-	cr16)
+	cr16 | cr16-*)
 		basic_machine=cr16-unknown
 		os=-elf
 		;;
@@ -672,7 +736,6 @@ case $basic_machine in
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
 		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i*86v32)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
@@ -730,11 +793,15 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-        microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-mingw32
 		;;
 	mingw32ce)
@@ -762,6 +829,10 @@ case $basic_machine in
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -769,10 +840,18 @@ case $basic_machine in
 	ms1-*)
 		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
+	msys)
+		basic_machine=i686-pc
+		os=-msys
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
+	nacl)
+		basic_machine=le32-unknown
+		os=-nacl
+		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
@@ -837,6 +916,12 @@ case $basic_machine in
 	np1)
 		basic_machine=np1-gould
 		;;
+	neo-tandem)
+		basic_machine=neo-tandem
+		;;
+	nse-tandem)
+		basic_machine=nse-tandem
+		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
@@ -919,9 +1004,10 @@ case $basic_machine in
 		;;
 	power)	basic_machine=power-ibm
 		;;
-	ppc)	basic_machine=powerpc-unknown
+	ppc | ppcbe)	basic_machine=powerpc-unknown
 		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+	ppc-* | ppcbe-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
@@ -946,7 +1032,11 @@ case $basic_machine in
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
 		basic_machine=i386-pc
 		os=-rdos
 		;;
@@ -1015,6 +1105,9 @@ case $basic_machine in
 		basic_machine=i860-stratus
 		os=-sysv4
 		;;
+	strongarm-* | thumb-*)
+		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
@@ -1071,20 +1164,8 @@ case $basic_machine in
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
-		;;
 	tile*)
-		basic_machine=tile-unknown
+		basic_machine=$basic_machine-unknown
 		os=-linux-gnu
 		;;
 	tx39)
@@ -1154,6 +1235,9 @@ case $basic_machine in
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
+	xscale-* | xscalee[bl]-*)
+		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
+		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
@@ -1251,9 +1335,12 @@ esac
 if [ x"$os" != x"" ]
 then
 case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
+	# First match some system type aliases
+	# that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
+	-auroraux)
+		os=-auroraux
+		;;
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
 		;;
@@ -1275,29 +1362,30 @@ case $os in
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -kopensolaris* \
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* | -cegcc* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1336,7 +1424,7 @@ case $os in
 	-opened*)
 		os=-openedition
 		;;
-        -os400*)
+	-os400*)
 		os=-os400
 		;;
 	-wince*)
@@ -1385,7 +1473,7 @@ case $os in
 	-sinix*)
 		os=-sysv4
 		;;
-        -tpf*)
+	-tpf*)
 		os=-tpf
 		;;
 	-triton*)
@@ -1421,15 +1509,14 @@ case $os in
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
 	-dicos*)
 		os=-dicos
 		;;
+	-nacl*)
+		;;
 	-none)
 		;;
 	*)
@@ -1452,10 +1539,10 @@ else
 # system, and we'll never get to this point.
 
 case $basic_machine in
-        score-*)
+	score-*)
 		os=-elf
 		;;
-        spu-*)
+	spu-*)
 		os=-elf
 		;;
 	*-acorn)
@@ -1467,8 +1554,23 @@ case $basic_machine in
 	arm*-semi)
 		os=-aout
 		;;
-        c4x-* | tic4x-*)
-        	os=-coff
+	c4x-* | tic4x-*)
+		os=-coff
+		;;
+	c8051-*)
+		os=-elf
+		;;
+	hexagon-*)
+		os=-elf
+		;;
+	tic54x-*)
+		os=-coff
+		;;
+	tic55x-*)
+		os=-coff
+		;;
+	tic6x-*)
+		os=-coff
 		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
@@ -1488,14 +1590,11 @@ case $basic_machine in
 		;;
 	m68000-sun)
 		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
-        mep-*)
+	mep-*)
 		os=-elf
 		;;
 	mips*-cisco)
@@ -1522,7 +1621,7 @@ case $basic_machine in
 	*-ibm)
 		os=-aix
 		;;
-    	*-knuth)
+	*-knuth)
 		os=-mmixware
 		;;
 	*-wec)
diff --git a/configure.in b/configure.in
index 08c8e1e97..96a0ee5e6 100644
--- a/configure.in
+++ b/configure.in
@@ -925,6 +925,44 @@ AC_HELP_STRING([--enable-ipod], [configure SDL to work with iPodLinux [[default=
     fi
 }
 
+CheckNintendoSwitch()
+{
+    AC_ARG_ENABLE(nintendo-switch,
+AC_HELP_STRING([--enable-nintendo-switch], [configure SDL to work with nintendo switch [[default=no]]]),
+        , enable_nintendo_switch=no)
+	if test x$enable_nintendo_switch = xyes; then
+        ARCH=nintendo-switch
+        NSWITCH_CFLAGS="-march=armv8-a -mtune=cortex-a57 -mtp=soft -fPIC \
+                     -Wall -O2 -ffunction-sections \
+                     -I$DEVKITPRO/libnx/include -D__SWITCH__"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $NSWITCH_CFLAGS"
+        CFLAGS="$CFLAGS $NSWITCH_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $NSWITCH_CFLAGS"
+        SDL_LIBS="-specs=${DEVKITPRO}/libnx/switch.specs -march=armv8-a -mtune=cortex-a57 -mtp=soft \
+                  -L${DEVKITPRO}/portlibs/switch/lib $SDL_LIBS \
+                  -L${DEVKITPRO}/libnx/lib -lnx"
+                AC_DEFINE(SDL_TIMER_NSWITCH)
+		SOURCES="$SOURCES $srcdir/src/timer/switch/*.c"
+		have_timers=yes
+		AC_DEFINE(SDL_AUDIO_DRIVER_NSWITCH)
+		SOURCES="$SOURCES $srcdir/src/audio/switch/*.c"
+		have_audio=yes
+		AC_DEFINE(SDL_JOYSTICK_NSWITCH)
+		SOURCES="$SOURCES $srcdir/src/joystick/switch/*.c"
+		have_joystick=yes
+		AC_DEFINE(SDL_THREAD_NSWITCH)
+		SOURCES="$SOURCES $srcdir/src/thread/switch/*.c"
+		have_threads=yes
+		AC_DEFINE(SDL_VIDEO_DRIVER_NSWITCH)
+		SOURCES="$SOURCES $srcdir/src/video/switch/*.c"
+		have_video=yes
+	fi
+}
+
+
+
+
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -2314,6 +2352,9 @@ AC_HELP_STRING([--enable-rpath], [use an rpath when linking SDL [[default=yes]]]
 
 dnl Set up the configuration based on the host platform!
 case "$host" in
+    aarch64-*-elf)
+       CheckNintendoSwitch
+       ;;
     arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
         ARCH=linux
         CheckDummyVideo
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 8bb1773c0..0080720e9 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -185,6 +185,7 @@
 #undef SDL_AUDIO_DRIVER_SNDMGR
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WAVEOUT
+#undef SDL_AUDIO_DRIVER_NSWITCH
 
 /* Enable various cdrom drivers */
 #undef SDL_CDROM_AIX
@@ -218,6 +219,7 @@
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
+#undef SDL_JOYSTICK_NSWITCH
 
 /* Enable various shared object loading systems */
 #undef SDL_LOADSO_BEOS
@@ -239,6 +241,7 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_SPROC
 #undef SDL_THREAD_WIN32
+#undef SDL_THREAD_NSWITCH
 
 /* Enable various timer systems */
 #undef SDL_TIMER_BEOS
@@ -251,6 +254,7 @@
 #undef SDL_TIMER_UNIX
 #undef SDL_TIMER_WIN32
 #undef SDL_TIMER_WINCE
+#undef SDL_TIMER_NSWITCH
 
 /* Enable various video drivers */
 #undef SDL_VIDEO_DRIVER_AALIB
@@ -293,6 +297,7 @@
 #undef SDL_VIDEO_DRIVER_X11_XRANDR
 #undef SDL_VIDEO_DRIVER_X11_XV
 #undef SDL_VIDEO_DRIVER_XBIOS
+#undef SDL_VIDEO_DRIVER_NSWITCH
 
 /* Enable OpenGL support */
 #undef SDL_VIDEO_OPENGL
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index beb26e0b4..57d1b3d00 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -104,6 +104,9 @@ static AudioBootStrap *bootstrap[] = {
 #if SDL_AUDIO_DRIVER_NDS
 	&NDSAUD_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_NSWITCH
+	&SWITCHAUD_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_MMEAUDIO
 	&MMEAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 74ac21df0..3d84fba50 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -170,6 +170,9 @@ extern AudioBootStrap DCAUD_bootstrap;
 #if SDL_AUDIO_DRIVER_NDS
 extern AudioBootStrap NDSAUD_bootstrap;
 #endif
+#if SDL_AUDIO_DRIVER_NSWITCH
+extern AudioBootStrap SWITCHAUD_bootstrap;
+#endif
 #if SDL_AUDIO_DRIVER_MMEAUDIO
 extern AudioBootStrap MMEAUDIO_bootstrap;
 #endif
diff --git a/src/audio/switch/SDL_switchaudio.c b/src/audio/switch/SDL_switchaudio.c
new file mode 100644
index 000000000..acc0329f4
--- /dev/null
+++ b/src/audio/switch/SDL_switchaudio.c
@@ -0,0 +1,191 @@
+/*
+
+*/
+#include "SDL_config.h"
+
+/* Output audio to nowhere... */
+
+#include "SDL_rwops.h"
+#include "SDL_timer.h"
+#include "SDL_audio.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+#include "SDL_switchaudio.h"
+
+#include <switch.h>
+#include <malloc.h>
+
+//extern volatile bool app_pause;
+extern volatile bool app_exiting;
+
+size_t stream_offset = 0;
+
+/* The tag name used by SWITCH audio */
+#define SWITCHAUD_DRIVER_NAME         "switch"
+
+/* Audio driver functions */
+static int SWITCH_OpenAudio(_THIS, SDL_AudioSpec *spec);
+static void SWITCH_WaitAudio(_THIS);
+static void SWITCH_PlayAudio(_THIS);
+static Uint8 *SWITCH_GetAudioBuf(_THIS);
+static void SWITCH_CloseAudio(_THIS);
+
+/* Audio driver bootstrap functions */
+static int SWITCH_Available(void)
+{
+	return(1);
+}
+
+static void SWITCH_DeleteDevice(SDL_AudioDevice *device)
+{
+
+	audoutExit();
+
+	SDL_free(device->hidden);
+	SDL_free(device);
+}
+
+static SDL_AudioDevice *SWITCH_CreateDevice(int devindex)
+{
+	SDL_AudioDevice *this;
+
+	if(audoutInitialize()) return (0);
+
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
+	if ( this ) {
+		SDL_memset(this, 0, (sizeof *this));
+		this->hidden = (struct SDL_PrivateAudioData *)
+				SDL_malloc((sizeof *this->hidden));
+	}
+	if ( (this == NULL) || (this->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( this ) {
+			SDL_free(this);
+		}
+		return(0);
+	}
+	SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+
+	/* Set the function pointers */
+	this->OpenAudio = SWITCH_OpenAudio;
+	this->WaitAudio = SWITCH_WaitAudio;
+	this->PlayAudio = SWITCH_PlayAudio;
+	this->GetAudioBuf = SWITCH_GetAudioBuf;
+	this->CloseAudio = SWITCH_CloseAudio;
+	this->free = SWITCH_DeleteDevice;
+
+	return this;
+}
+
+AudioBootStrap SWITCHAUD_bootstrap = {
+	SWITCHAUD_DRIVER_NAME, "SDL Switch audio driver",
+	SWITCH_Available, SWITCH_CreateDevice
+};
+
+/* This function waits until it is possible to write a full sound buffer */
+static void SWITCH_WaitAudio(_THIS)
+{
+
+}
+
+static void SWITCH_PlayAudio(_THIS)
+{
+    if(	this->hidden->next > this->hidden->released_count)
+		audoutWaitPlayFinish(&this->hidden->released_buffer, &this->hidden->released_count, U64_MAX);
+	audoutAppendAudioOutBuffer(&this->hidden->waveBuf[this->hidden->next%NUM_BUFFERS]);
+	this->hidden->next++;
+}
+
+static Uint8 *SWITCH_GetAudioBuf(_THIS)
+{
+	return this->hidden->waveBuf[this->hidden->next%NUM_BUFFERS].buffer;
+}
+
+static void SWITCH_CloseAudio(_THIS)
+{
+	int i;
+	audoutStopAudioOut();
+	
+	for(i=0; i<NUM_BUFFERS; i++)
+	{
+		if 	( this->hidden->waveBuf[i].buffer!= NULL )
+			free(this->hidden->waveBuf[i].buffer);
+		this->hidden->waveBuf[i].buffer= NULL;
+	}
+}
+
+static int SWITCH_OpenAudio(_THIS, SDL_AudioSpec *spec)
+{	
+	int i;
+	if(audoutStartAudioOut()) return (-1);
+
+	spec->channels = 2;
+	spec->freq = 48000;
+
+    Uint16 test_format = SDL_FirstAudioFormat(spec->format);
+    int valid_datatype = 0;
+    while ((!valid_datatype) && (test_format)) {
+        spec->format = test_format;
+        switch (test_format) {
+/* 
+			case AUDIO_S8:
+				// Signed 8-bit audio actually unsupported 
+				this->hidden->format=PcmFormat_INT8;
+//				this->hidden->isSigned=1;
+				this->hidden->bytePerSample = (spec->channels);
+				   valid_datatype = 1;
+				break;
+*/
+			case AUDIO_S16LSB:
+				/* Signed 16-bit audio supported */
+				this->hidden->format=PcmFormat_Int16;
+				this->hidden->bytePerSample = (spec->channels) * 2;
+				   valid_datatype = 1;
+				break;
+			default:
+				test_format = SDL_NextAudioFormat();
+				break;
+		}
+	}
+
+    if (!valid_datatype) {  /* shouldn't happen, but just in case... */
+        SDL_SetError("Unsupported audio format");
+		audoutStopAudioOut();
+        return (-1);
+    }
+
+	/* Update the fragment size as size in bytes */
+	SDL_CalculateAudioSpec(spec);
+
+	/* Allocate mixing buffer */
+	this->hidden->mixlen = spec->size;
+	
+	int size_aligned = (spec->size + 0xfff) & ~0xfff;
+	
+	for(i=0; i<NUM_BUFFERS; i++) 
+	{
+		this->hidden->waveBuf[i].buffer = memalign(0x1000,size_aligned);
+		this->hidden->waveBuf[i].buffer_size = size_aligned;
+		this->hidden->waveBuf[i].data_size = spec->size;
+		this->hidden->waveBuf[i].next = NULL;
+		this->hidden->waveBuf[i].data_offset = 0;
+		memset(this->hidden->waveBuf[i].buffer,0,size_aligned);
+    }
+	this->hidden->released_count=0;
+	this->hidden->next = 0;
+
+//	this->hidden->channels = spec->channels;
+//	this->hidden->samplerate = spec->freq;
+	
+	for(i=0; i<NUM_BUFFERS; i++) 
+	{
+		audoutAppendAudioOutBuffer(&this->hidden->waveBuf[i]);
+	}
+	// lets wait for the first buffer to be released 
+	audoutWaitPlayFinish(&this->hidden->released_buffer, &this->hidden->released_count, U64_MAX);
+	
+	/* We're ready to rock and roll. :-) */
+	return(0);
+}
diff --git a/src/audio/switch/SDL_switchaudio.h b/src/audio/switch/SDL_switchaudio.h
new file mode 100644
index 000000000..c3be64ed4
--- /dev/null
+++ b/src/audio/switch/SDL_switchaudio.h
@@ -0,0 +1,48 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include <switch.h>
+#include "SDL_config.h"
+
+#ifndef _SDL_switchaudio_h
+#define _SDL_switchaudio_h
+
+#include "../SDL_sysaudio.h"
+
+#define _THIS	SDL_AudioDevice *this
+
+#define NUM_BUFFERS 4			 
+
+struct SDL_PrivateAudioData {
+	/* The file descriptor for the audio device */
+
+	Uint32 mixlen;
+	Uint32 format;
+//    Uint32 samplerate;
+//	Uint32 channels;
+    Uint8  bytePerSample;
+	AudioOutBuffer waveBuf[NUM_BUFFERS];
+	AudioOutBuffer *released_buffer;
+	u32 released_count;
+	u32 next;
+};
+
+#endif /* _SDL_switchaudio_h */
diff --git a/src/audio/switch/SDL_switchaudio.o b/src/audio/switch/SDL_switchaudio.o
new file mode 100644
index 000000000..c67122617
Binary files /dev/null and b/src/audio/switch/SDL_switchaudio.o differ
diff --git a/src/joystick/switch/SDL_sysjoystick.c b/src/joystick/switch/SDL_sysjoystick.c
new file mode 100644
index 000000000..37be44677
--- /dev/null
+++ b/src/joystick/switch/SDL_sysjoystick.c
@@ -0,0 +1,83 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#if defined(SDL_JOYSTICK_NSWITCH)
+
+/* This is the system specific header for the SDL joystick API */
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+/* Function to scan the system for joysticks.
+ * This function should set SDL_numjoysticks to the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return 0, or -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	SDL_numjoysticks = 0;
+	return(0);
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	SDL_SetError("Logic error: No joysticks available");
+	return(NULL);
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	SDL_SetError("Logic error: No joysticks available");
+	return(-1);
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	return;
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	return;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+	return;
+}
+
+#endif /* SDL_JOYSTICK_NSWITCH */
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 8af6e52f4..0cc93e674 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -43,6 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
+#elif SDL_THREAD_NSWITCH
+#include "switch/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/switch/SDL_syscond.c b/src/thread/switch/SDL_syscond.c
new file mode 100644
index 000000000..4b5282856
--- /dev/null
+++ b/src/thread/switch/SDL_syscond.c
@@ -0,0 +1,158 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+//#include "../../SDL_internal.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+#include "SDL_config.h"
+
+#include "SDL_thread.h"
+
+#include <switch.h>
+
+struct SDL_cond
+{
+	CondVar cond;
+	Mutex mutex;
+};
+
+struct SDL_mutex 
+{
+	Mutex mutex;
+};
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    SDL_cond *cond;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(*cond));
+    if (!cond) {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond * cond)
+{
+    if (cond) {
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond * cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+    condvarWakeOne(&cond->cond);
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond * cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    condvarWakeAll(&cond->cond);
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int
+SDL_CondWaitTimeout(SDL_cond * cond, SDL_mutex * mutex, Uint32 ms)
+{
+    int retval;
+
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+     condvarInit(&cond->cond, &mutex->mutex);
+
+    /* Unlock the mutex, as is required by condition variable semantics */
+    SDL_UnlockMutex(mutex);
+
+    retval =  condvarWaitTimeout(&cond->cond, (ms == SDL_MUTEX_MAXWAIT) ? U64_MAX : (signed long long)ms*1000000);
+
+    /* Lock the mutex, as is required by condition variable semantics */
+    SDL_LockMutex(mutex);
+
+    return retval;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond * cond, SDL_mutex * mutex)
+{
+   int retval;
+
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    condvarInit(&cond->cond, &mutex->mutex);
+	
+    /* Unlock the mutex, as is required by condition variable semantics */
+    SDL_UnlockMutex(mutex);
+
+    retval =  condvarWait(&cond->cond);
+
+    /* Lock the mutex, as is required by condition variable semantics */
+    SDL_LockMutex(mutex);
+
+    return retval;
+}
diff --git a/src/thread/switch/SDL_syscond.o b/src/thread/switch/SDL_syscond.o
new file mode 100644
index 000000000..02787b3b9
Binary files /dev/null and b/src/thread/switch/SDL_syscond.o differ
diff --git a/src/thread/switch/SDL_sysmutex.c b/src/thread/switch/SDL_sysmutex.c
new file mode 100644
index 000000000..e9b54d4e3
--- /dev/null
+++ b/src/thread/switch/SDL_sysmutex.c
@@ -0,0 +1,122 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <switch.h>
+
+struct SDL_mutex {
+	int recursive;
+	Uint32 owner;
+	Mutex mutex;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+	SDL_mutex *mutex;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *)SDL_malloc(sizeof(*mutex));
+	if ( mutex ) {
+		mutexInit(&mutex->mutex);
+		mutex->recursive = 0;
+		mutex->owner = 0;
+	} else {
+		SDL_OutOfMemory();
+	}
+	return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+	if ( mutex ) {
+		SDL_free(mutex);
+	}
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+#if SDL_THREADS_DISABLED
+	return  SDL_arraysize(return ),0;
+#else
+	Uint32 this_thread;
+
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	this_thread = SDL_ThreadID();
+	if ( mutex->owner == this_thread ) {
+		++mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   We set the locking thread id after we obtain the lock
+		   so unlocks from other threads will fail.
+		*/
+		mutexLock(&mutex->mutex);
+		mutex->owner = this_thread;
+		mutex->recursive = 0;
+	}
+
+	return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+#if SDL_THREADS_DISABLED
+	return 0;
+#else
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	/* If we don't own the mutex, we can't unlock it */
+	if ( SDL_ThreadID() != mutex->owner ) {
+		SDL_SetError("mutex not owned by this thread");
+		return -1;
+	}
+
+	if ( mutex->recursive ) {
+		--mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   First reset the owner so another thread doesn't lock
+		   the mutex and set the ownership before we reset it,
+		   then release the lock semaphore.
+		 */
+		mutex->owner = 0;
+		mutexUnlock(&mutex->mutex);
+	}
+	return 0;
+#endif /* SDL_THREADS_DISABLED */
+}
diff --git a/src/thread/switch/SDL_sysmutex.o b/src/thread/switch/SDL_sysmutex.o
new file mode 100644
index 000000000..d57475580
Binary files /dev/null and b/src/thread/switch/SDL_sysmutex.o differ
diff --git a/src/thread/switch/SDL_syssem.c b/src/thread/switch/SDL_syssem.c
new file mode 100644
index 000000000..bb74fd974
--- /dev/null
+++ b/src/thread/switch/SDL_syssem.c
@@ -0,0 +1,210 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+
+#if SDL_THREADS_DISABLED
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_SetError("SDL not configured with thread support");
+	return (SDL_sem *)0;
+}
+
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+	return;
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+	SDL_SetError("SDL not configured with thread support");
+	return -1;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+	SDL_SetError("SDL not configured with thread support");
+	return -1;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+	SDL_SetError("SDL not configured with thread support");
+	return -1;
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+	return 0;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+	SDL_SetError("SDL not configured with thread support");
+	return -1;
+}
+
+#else
+
+struct SDL_semaphore
+{
+	Uint32 count;
+	Uint32 waiters_count;
+	SDL_mutex *count_lock;
+	SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_sem *sem;
+
+	sem = (SDL_sem *)SDL_malloc(sizeof(*sem));
+	if ( ! sem ) {
+		SDL_OutOfMemory();
+		return NULL;
+	}
+	sem->count = initial_value;
+	sem->waiters_count = 0;
+
+	sem->count_lock = SDL_CreateMutex();
+	sem->count_nonzero = SDL_CreateCond();
+	if ( ! sem->count_lock || ! sem->count_nonzero ) {
+		SDL_DestroySemaphore(sem);
+		return NULL;
+	}
+
+	return sem;
+}
+
+/* WARNING:
+   You cannot call this function when another thread is using the semaphore.
+*/
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+	if ( sem ) {
+		sem->count = 0xFFFFFFFF;
+		while ( sem->waiters_count > 0) {
+			SDL_CondSignal(sem->count_nonzero);
+			SDL_Delay(10);
+		}
+		SDL_DestroyCond(sem->count_nonzero);
+		if ( sem->count_lock ) {
+			SDL_mutexP(sem->count_lock);
+			SDL_mutexV(sem->count_lock);
+			SDL_DestroyMutex(sem->count_lock);
+		}
+		SDL_free(sem);
+	}
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+	int retval;
+
+	if ( ! sem ) {
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	retval = SDL_MUTEX_TIMEDOUT;
+	SDL_LockMutex(sem->count_lock);
+	if ( sem->count > 0 ) {
+		--sem->count;
+		retval = 0;
+	}
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+	int retval;
+
+	if ( ! sem ) {
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	/* A timeout of 0 is an easy case */
+	if ( timeout == 0 ) {
+		return SDL_SemTryWait(sem);
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	++sem->waiters_count;
+	retval = 0;
+	while ( (sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT) ) {
+		retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock, timeout);
+	}
+	--sem->waiters_count;
+	if (retval == 0) {
+		--sem->count;
+	}
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+	return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+	Uint32 value;
+	
+	value = 0;
+	if ( sem ) {
+		SDL_LockMutex(sem->count_lock);
+		value = sem->count;
+		SDL_UnlockMutex(sem->count_lock);
+	}
+	return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+	if ( ! sem ) {
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	if ( sem->waiters_count > 0 ) {
+		SDL_CondSignal(sem->count_nonzero);
+	}
+	++sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return 0;
+}
+
+#endif /* SDL_THREADS_DISABLED */
diff --git a/src/thread/switch/SDL_syssem.o b/src/thread/switch/SDL_syssem.o
new file mode 100644
index 000000000..16bca5e8b
Binary files /dev/null and b/src/thread/switch/SDL_syssem.o differ
diff --git a/src/thread/switch/SDL_systhread.c b/src/thread/switch/SDL_systhread.c
new file mode 100644
index 000000000..3233b4d04
--- /dev/null
+++ b/src/thread/switch/SDL_systhread.c
@@ -0,0 +1,107 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+	  claim that you wrote the original software. If you use this software
+	  in a product, an acknowledgment in the product documentation would be
+	  appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+	  misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc.h>
+
+#include "SDL_config.h"
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+#include <switch.h>
+
+#define STACKSIZE       (4 * 1024)
+
+void ThreadEntry(void *arg)
+{
+	SDL_RunThread(arg);
+//	while(1) SDL_Delay(-1); // this is for RyujiNX
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+	s32 priority = 0x2B;
+	Thread *tempThread;
+	int rc=-1;
+	
+	tempThread = malloc(sizeof(Thread));
+	
+/*
+	// Set priority of new thread higher than the current thread 
+	svcGetThreadPriority(&priority, CURRENT_KTHREAD); //  0x2C is the usual priority of the main thread.
+	if(priority>0x0) priority--;
+*/
+	rc = threadCreate(tempThread, ThreadEntry, args, STACKSIZE, priority, -2);
+	if (R_FAILED(rc))
+	{
+		SDL_SetError("Create Thread failed");
+		return(-1);
+	}
+	
+	rc = threadStart(tempThread);
+	if (R_FAILED(rc))
+	{
+		SDL_SetError("Start Thread failed");
+		return(-1);
+	}
+
+	thread->handle = tempThread;
+	
+	thread->threadid = (int) tempThread->handle;
+ 
+	return 0;
+}
+
+void SDL_SYS_SetupThread(void)
+{
+	 //Nothing, probably
+}
+
+Uint32 SDL_ThreadID(void)
+{
+	return (Uint32) armGetTls();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+
+	if(thread->handle) {
+		threadWaitForExit((Thread *) thread->handle);
+		threadClose((Thread *) thread->handle);
+		free(thread);
+		thread->handle = NULL;
+	}	
+
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+	if(thread->handle)
+	{
+//		threadPause((Thread *) thread->handle);
+		threadClose((Thread *) thread->handle);
+		free(thread);
+		thread->handle = NULL;
+	}
+}
diff --git a/src/thread/switch/SDL_systhread.o b/src/thread/switch/SDL_systhread.o
new file mode 100644
index 000000000..bc939b8bf
Binary files /dev/null and b/src/thread/switch/SDL_systhread.o differ
diff --git a/src/thread/switch/SDL_systhread_c.h b/src/thread/switch/SDL_systhread_c.h
new file mode 100644
index 000000000..112c4ead9
--- /dev/null
+++ b/src/thread/switch/SDL_systhread_c.h
@@ -0,0 +1,24 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2014 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <switch.h>
+
+typedef Thread* SYS_ThreadHandle;
diff --git a/src/timer/switch/SDL_systimer.c b/src/timer/switch/SDL_systimer.c
new file mode 100644
index 000000000..e31140412
--- /dev/null
+++ b/src/timer/switch/SDL_systimer.c
@@ -0,0 +1,47 @@
+#include "SDL_config.h"
+
+#include <sys/time.h>
+#include <switch.h>
+#include <sys/select.h>
+
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_error.h"
+#include "../SDL_timer_c.h"
+
+static struct timeval start;
+
+void SDL_StartTicks (void) {
+	gettimeofday (&start, NULL);
+}
+
+Uint32 SDL_GetTicks (void) {
+	Uint32 ticks;
+	struct timeval now;
+
+	gettimeofday (&now, NULL);
+	ticks = (now.tv_sec - start.tv_sec) * 1000 + (now.tv_usec - start.tv_usec) / 1000;
+
+	return (ticks);
+}
+
+void SDL_Delay (Uint32 ms) {
+		svcSleepThread((Uint64)ms * 1000000);
+}
+
+int SDL_SYS_TimerInit (void) {
+	return 0;
+}
+
+void SDL_SYS_TimerQuit (void) {
+}
+
+int SDL_SYS_StartTimer (void) {
+	SDL_SetError ("Timers not implemented on Switch");
+
+	return -1;
+}
+
+void SDL_SYS_StopTimer (void) {
+}
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 436450e33..c498b28ae 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -410,6 +410,9 @@ extern VideoBootStrap AALIB_bootstrap;
 #if SDL_VIDEO_DRIVER_CACA
 extern VideoBootStrap CACA_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_NSWITCH
+extern VideoBootStrap SWITCH_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 46285c990..1971f5108 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -126,6 +126,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_CACA
 	&CACA_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_NSWITCH
+	&SWITCH_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
diff --git a/src/video/switch/SDL_switchevents.c b/src/video/switch/SDL_switchevents.c
new file mode 100644
index 000000000..dd342a32b
--- /dev/null
+++ b/src/video/switch/SDL_switchevents.c
@@ -0,0 +1,141 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/ 
+#include "SDL_config.h"
+
+/* Being a null driver, there's no event stream. We just define stubs for
+   most of the API. */
+
+#include "switch.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_switchvideo.h"
+#include "SDL_switchevents_c.h"
+
+static SDLKey keymap[SWITCH_NUMKEYS];
+char keymem[SWITCH_NUMKEYS];
+
+void SWITCH_PumpEvents(_THIS)
+{
+	if(!appletMainLoop())
+	{
+		SDL_Event sdlevent;
+		sdlevent.type = SDL_QUIT;
+		SDL_PushEvent(&sdlevent);
+	} 
+	
+	int i;
+	u32 keys;
+	SDL_keysym keysym;
+	keysym.mod = KMOD_NONE;
+
+	hidScanInput();
+	keys = hidKeysHeld(CONTROLLER_P1_AUTO);
+
+	for (i = 0; i < SWITCH_NUMKEYS; i++) {
+		keysym.scancode = i;
+		keysym.sym = keymap[i];
+
+		if (keys & (1 << i) && !keymem[i]) {
+			keymem[i] = 1;
+
+			SDL_PrivateKeyboard (SDL_PRESSED, &keysym);
+		}
+
+		if (!(keys & (1 << i)) && keymem[i]) {
+			keymem[i] = 0;
+
+			SDL_PrivateKeyboard (SDL_RELEASED, &keysym);
+		}
+	}
+	
+	if (hidKeysHeld(CONTROLLER_P1_AUTO) & KEY_TOUCH) {
+			
+		touchPosition touch;
+
+		hidTouchRead (&touch,0);
+		
+		int xtouch, ytouch;
+		
+		xtouch = (touch.px / 1280.0) * this->hidden->pw - (this->hidden->pw-this->hidden->w)/2;
+		if (xtouch >= this->hidden->w) xtouch = -1;
+
+		ytouch = (touch.py / 720.0) * this->hidden->ph - (this->hidden->ph-this->hidden->h)/2;
+		if (ytouch > this->hidden->h) ytouch = -1;
+		
+		if (xtouch >= 0 && xtouch >= 0 ) {
+			SDL_PrivateMouseMotion (0, 0, xtouch, ytouch);
+			if (!SDL_GetMouseState (NULL, NULL))
+				SDL_PrivateMouseButton (SDL_PRESSED, 1, 0, 0);
+		}
+	} else {
+		if (SDL_GetMouseState (NULL, NULL))
+			SDL_PrivateMouseButton (SDL_RELEASED, 1, 0, 0);
+	}
+}
+
+void SWITCH_InitOSKeymap(_THIS)
+{
+	SDL_memset(keymem,1,SWITCH_NUMKEYS);
+	keymap[0]=SDLK_a; //KEY_A
+	keymap[1]=SDLK_b; // KEY_B
+	keymap[2]=SDLK_x; //KEY_X 
+	keymap[3]=SDLK_y; //KEY_Y
+	keymap[4]=SDLK_LSHIFT;  //left stick button 
+	keymap[5]=SDLK_RSHIFT;  //right stick button
+	keymap[6]=SDLK_l; //KEY_L
+	keymap[7]=SDLK_r; //KEY_R
+	keymap[8]=SDLK_j; //KEY_ZL
+	keymap[9]=SDLK_k; //KEY_ZR
+	keymap[10]=SDLK_MINUS; //KEY_MINUS 
+	keymap[11]=SDLK_PLUS; //KEY_PLUS
+	keymap[12]=SDLK_LEFT; //KEY_LEFT
+	keymap[13]=SDLK_UP; // KEY_UP
+	keymap[14]=SDLK_RIGHT; //KEY_RIGHT
+	keymap[15]=SDLK_DOWN; //KEY_DOWN
+	keymap[16]=SDLK_UNKNOWN; 
+	keymap[17]=SDLK_UNKNOWN; 
+	keymap[18]=SDLK_UNKNOWN; 
+	keymap[19]=SDLK_UNKNOWN; 
+	keymap[20]=SDLK_UNKNOWN; 
+	keymap[21]=SDLK_UNKNOWN; 
+	keymap[22]=SDLK_UNKNOWN; 
+	keymap[23]=SDLK_UNKNOWN; 
+	keymap[24]=SDLK_UNKNOWN; 
+	keymap[25]=SDLK_UNKNOWN; 
+	keymap[26]=SDLK_UNKNOWN; 
+	keymap[27]=SDLK_UNKNOWN; 
+	keymap[28]=SDLK_UNKNOWN; 
+	keymap[29]=SDLK_UNKNOWN; 
+	keymap[30]=SDLK_UNKNOWN; 
+	keymap[31]=SDLK_UNKNOWN; 
+
+// init the key state
+	int i;
+	hidScanInput();
+	for (i = 0; i < SWITCH_NUMKEYS; i++)
+		keymem[i] = (hidKeysHeld(CONTROLLER_P1_AUTO) & (1 << i))?1:0;
+		
+}
+
+/* end of SDL_nullevents.c ... */
+
diff --git a/src/video/switch/SDL_switchevents_c.h b/src/video/switch/SDL_switchevents_c.h
new file mode 100644
index 000000000..5843bb1c1
--- /dev/null
+++ b/src/video/switch/SDL_switchevents_c.h
@@ -0,0 +1,35 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_switchvideo.h"
+
+#define SWITCH_NUMKEYS 32
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern void SWITCH_InitOSKeymap(_THIS);
+extern void SWITCH_PumpEvents(_THIS);
+
+/* end of SDL_nullevents_c.h ... */
+
diff --git a/src/video/switch/SDL_switchmouse.c b/src/video/switch/SDL_switchmouse.c
new file mode 100644
index 000000000..56d49dbeb
--- /dev/null
+++ b/src/video/switch/SDL_switchmouse.c
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_switchmouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/switch/SDL_switchmouse_c.h b/src/video/switch/SDL_switchmouse_c.h
new file mode 100644
index 000000000..d231b8570
--- /dev/null
+++ b/src/video/switch/SDL_switchmouse_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_switchvideo.h"
+
+/* Functions to be exported */
diff --git a/src/video/switch/SDL_switchvideo.c b/src/video/switch/SDL_switchvideo.c
new file mode 100644
index 000000000..7c13896ce
--- /dev/null
+++ b/src/video/switch/SDL_switchvideo.c
@@ -0,0 +1,469 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+#include <switch.h>
+
+/* SWITCH SDL video driver implementation; 
+ */
+
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_switchvideo.h"
+#include "SDL_switchevents_c.h"
+#include "SDL_switchmouse_c.h"
+
+#define SWITCHVID_DRIVER_NAME "switch"
+
+static Uint32 switch_palette[256] = {0};
+
+
+/* Initialization/Query functions */
+static int SWITCH_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **SWITCH_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+static SDL_Surface *SWITCH_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
+static int SWITCH_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors);
+static void SWITCH_VideoQuit(_THIS);
+
+/* Hardware surface functions */
+static int SWITCH_AllocHWSurface(_THIS, SDL_Surface *surface);
+static int SWITCH_LockHWSurface(_THIS, SDL_Surface *surface);
+static void SWITCH_UnlockHWSurface(_THIS, SDL_Surface *surface);
+static void SWITCH_FreeHWSurface(_THIS, SDL_Surface *surface);
+static int SWITCH_FlipHWSurface (_THIS, SDL_Surface *surface);
+
+/* etc. */
+static void SWITCH_UpdateRects(_THIS, int numrects, SDL_Rect *rects);
+int SWITCH_ToggleFullScreen(_THIS, int on);
+
+
+void SWITCH_SetResolution(_THIS)
+{
+	float rx,ry;
+	rx = 1280.0/this->hidden->w;
+	ry = 720.0/this->hidden->h;
+	if(rx>ry) rx=ry;
+	gfxConfigureResolution(1280/rx, 720/rx);
+	this->hidden->pw=1280/rx;
+	this->hidden->ph=720/rx;
+	gfxSetMode(GfxMode_TiledDouble);
+}
+
+/* SWITCH driver bootstrap functions */
+
+static int SWITCH_Available(void)
+{
+	return(1);
+}
+
+static void SWITCH_DeleteDevice(SDL_VideoDevice *device)
+{
+	SDL_free(device->hidden);
+	SDL_free(device);
+	device=NULL;
+}
+
+static SDL_VideoDevice *SWITCH_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+				SDL_malloc((sizeof *device->hidden));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( device ) {
+			SDL_free(device);
+		}
+		return(0);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+	/* Set the function pointers */
+	device->VideoInit = SWITCH_VideoInit;
+	device->ListModes = SWITCH_ListModes;
+	device->SetVideoMode = SWITCH_SetVideoMode;
+	device->CreateYUVOverlay = NULL;
+	device->SetColors = SWITCH_SetColors;
+	device->UpdateRects = SWITCH_UpdateRects;
+	device->VideoQuit = SWITCH_VideoQuit;
+	device->AllocHWSurface = SWITCH_AllocHWSurface;
+	device->CheckHWBlit = NULL;
+	device->FillHWRect = NULL;
+	device->SetHWColorKey = NULL;
+	device->SetHWAlpha = NULL;
+	device->LockHWSurface = SWITCH_LockHWSurface;
+	device->UnlockHWSurface = SWITCH_UnlockHWSurface;
+	device->FlipHWSurface = SWITCH_FlipHWSurface;
+	device->FreeHWSurface = SWITCH_FreeHWSurface;
+	device->SetCaption = NULL;
+	device->SetIcon = NULL;
+	device->IconifyWindow = NULL;
+	device->GrabInput = NULL;
+	device->GetWMInfo = NULL;
+	device->InitOSKeymap = SWITCH_InitOSKeymap;
+	device->PumpEvents = SWITCH_PumpEvents;
+
+	device->ToggleFullScreen = SWITCH_ToggleFullScreen;
+
+	device->free = SWITCH_DeleteDevice;
+
+	return device;
+}
+
+VideoBootStrap SWITCH_bootstrap = {
+	SWITCHVID_DRIVER_NAME, "SDL Switch video driver",
+	SWITCH_Available, SWITCH_CreateDevice
+};
+
+
+int SWITCH_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	gfxInitDefault();
+//	gfxConfigureAutoResolutionDefault(true);
+	vformat->BitsPerPixel = 32;
+	vformat->BytesPerPixel = 4;
+	vformat->Rmask = 0x000000ff;
+	vformat->Gmask = 0x0000ff00;
+	vformat->Bmask = 0x00ff0000; 
+	vformat->Amask = 0xff000000; 
+
+	/* We're done! */
+	return(0);
+}
+
+SDL_Rect **SWITCH_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+   	 return (SDL_Rect **) -1;
+}
+
+int SWITCH_ToggleFullScreen(_THIS, int on){
+	this->hidden->clearbuffer=2;
+
+	if ( this->hidden->flags & SDL_FULLSCREEN ) {
+		this->hidden->flags &= ~SDL_FULLSCREEN;
+		gfxConfigureResolution(0, 0);
+		gfxSetMode(GfxMode_LinearDouble);
+		this->hidden->pw=1280;
+		this->hidden->ph=720;
+	} else {
+		this->hidden->flags |= SDL_FULLSCREEN;
+		SWITCH_SetResolution(this);
+	}
+	return 1;
+}
+
+SDL_Surface *SWITCH_SetVideoMode(_THIS, SDL_Surface *current,
+				int width, int height, int bpp, Uint32 flags)
+{
+	Uint32 Rmask, Gmask, Bmask, Amask; 
+
+	switch(bpp) {
+		case 0:
+			bpp = 32;
+		case 32:
+			Rmask = 0x000000ff; 
+			Gmask = 0x0000ff00;
+			Bmask = 0x00ff0000;
+			Amask = 0xff000000;
+			break;
+		case 24:
+			Rmask = 0x0000ff; 
+			Gmask = 0x00ff00;
+			Bmask = 0xff0000;
+			Amask = 0x0;
+			break;
+		case 16:
+			Rmask = 0xF800;
+            Gmask = 0x07E0;
+            Bmask = 0x001F;
+            Amask = 0x0000;
+			break;
+		case 8:
+			Rmask = 0;
+			Gmask = 0;
+			Bmask = 0;
+			Amask = 0;
+			break;
+		default:
+			return NULL;
+			break;
+	}
+
+	if ( this->hidden->buffer ) {
+		SDL_free( this->hidden->buffer );
+	}
+
+	this->hidden->buffer = SDL_malloc(width * height * (bpp / 8));
+	if ( ! this->hidden->buffer ) {
+		SDL_SetError("Couldn't allocate buffer for requested mode");
+		return(NULL);
+	}
+
+/* 	printf("Setting mode %dx%d\n", width, height); */
+
+	SDL_memset(this->hidden->buffer, 0, width * height * (bpp / 8));
+
+	/* Set up the new mode framebuffer */
+	this->hidden->flags = current->flags =  SDL_HWSURFACE | SDL_DOUBLEBUF | (flags & SDL_FULLSCREEN);
+//	this->hidden->flags = current->flags =  flags;
+	this->info.current_w = this->hidden->w = current->w = width;
+	this->info.current_h = this->hidden->h = current->h = height;
+	this->hidden->bpp = bpp;
+	current->pitch = current->w * (bpp / 8);
+	current->pixels = this->hidden->buffer;
+
+	/* Allocate the new pixel format for the screen */
+	if ( ! SDL_ReallocFormat(current, bpp, Rmask, Gmask, Bmask, Amask) ) {
+		SDL_free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		SDL_SetError("Couldn't allocate new pixel format for requested mode");
+		return(NULL);
+	}
+
+	this->hidden->pw=1280;
+	this->hidden->ph=720;
+	gfxConfigureResolution(0, 0);
+	gfxSetMode(GfxMode_LinearDouble);
+	
+	if (flags & SDL_FULLSCREEN) SWITCH_SetResolution(this);
+
+	// lets clead the phisical video buffer, in case we are changing to a smaller screen
+//	u32 w, h;
+//	u32* framebuf = (u32*) gfxGetFramebuffer((u32*)&w, (u32*)&h);
+
+//	memset(framebuf,0,w*h*4);
+	this->hidden->clearbuffer=2;
+	
+	/* We're done */
+	return(current);
+}
+
+/* We don't actually allow hardware surfaces other than the main one */
+static int SWITCH_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+
+static void SWITCH_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+/* We need to wait for vertical retrace on page flipped displays */
+static int SWITCH_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+
+static void SWITCH_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static void SWITCH_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+	SWITCH_FlipHWSurface (this, NULL);
+
+} 
+
+int SWITCH_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
+{
+	int i;
+	for ( i = firstcolor; i < firstcolor + ncolors; ++i )
+		switch_palette[i] = RGBA8(colors[i].r, colors[i].g, colors[i].b, 0xff);
+	return(1);
+}
+
+/* Note:  If we are terminated, this could be called in the middle of
+   another SDL video routine -- notably UpdateRects.
+*/
+void SWITCH_VideoQuit(_THIS)
+{
+	if (this->hidden->buffer != NULL)
+	{
+		SDL_free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+	}
+	gfxExit();
+}
+
+static int SWITCH_FlipHWSurface (_THIS, SDL_Surface *surface) {
+	u32 width, height;
+	u32 pos_src, pos_dst;
+	u32* framebuf = (u32*) gfxGetFramebuffer((u32*)&width, (u32*)&height);
+	u8* videobuf = (u8*) this->hidden->buffer;
+	u16* videobuf_16 = (u16*) this->hidden->buffer;
+
+	//clear HW buffers after startup, toggle fullscreen, and maybe other situations in future...
+	if(this->hidden->clearbuffer) {
+		memset(framebuf,0,1280*720*4);
+		this->hidden->clearbuffer--;
+	}
+
+	u32 x, y, offx, offy;
+
+	if(width > this->info.current_w)
+		offx = (width - this->info.current_w) / 2;
+	else
+		offx = 0;
+
+	if(height > this->info.current_h)
+		offy = (height - this->info.current_h) / 2;
+	else 	
+		offy = 0;
+		
+	if(this->hidden->flags & SDL_FULLSCREEN) {
+
+		pos_src = 0;
+				
+		switch(this->hidden->bpp) {
+		
+			case 32:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[gfxGetFramebufferDisplayOffset(x+offx,y+offy)] = RGBA8(videobuf[pos_src+0], videobuf[pos_src+1], videobuf[pos_src+2], videobuf[pos_src+3]);
+						pos_src += 4;
+					}
+					pos_src = pos_src - x*4 + this->info.current_w*4;
+				}
+				break;
+			case 24:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[gfxGetFramebufferDisplayOffset(x+offx,y+offy)] = RGBA8(videobuf[pos_src+0], videobuf[pos_src+1], videobuf[pos_src+2], 0xff);
+						pos_src += 3;
+					}
+					pos_src = pos_src - x*3 + this->info.current_w*3;
+				}
+				break;
+			case 16:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[gfxGetFramebufferDisplayOffset(x+offx,y+offy)] = RGBA8((videobuf_16[pos_src]&0xF800)>>8,(videobuf_16[pos_src]&0x07E0)>>3, (videobuf_16[pos_src]&0x001F)<<3,0xff);
+						pos_src++;
+					}
+					pos_src = pos_src - x + this->info.current_w;
+				}
+
+				break;
+			case 8:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[gfxGetFramebufferDisplayOffset(x+offx,y+offy)] = switch_palette[videobuf[pos_src]];
+						pos_src++;
+					}
+					pos_src = pos_src - x + this->info.current_w;
+				}
+				break;
+			default:
+				break;
+		}
+	
+	} else {
+	
+		pos_dst = offy * width + offx;
+		pos_src = 0;
+
+				
+		switch(this->hidden->bpp) {
+		
+			case 32:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[pos_dst] = RGBA8(videobuf[pos_src+0], videobuf[pos_src+1], videobuf[pos_src+2], videobuf[pos_src+3]);
+						pos_dst++;
+						pos_src += 4;
+					}
+					pos_dst = pos_dst -x + width;
+					pos_src = pos_src - x*4 + this->info.current_w*4;
+				}
+				break;
+			case 24:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[pos_dst] = RGBA8(videobuf[pos_src+0], videobuf[pos_src+1], videobuf[pos_src+2], 0xff);
+						pos_dst++;
+						pos_src += 3;
+					}
+					pos_dst = pos_dst - x + width;
+					pos_src = pos_src - x*3 + this->info.current_w*3;
+				}
+				break;
+			case 16:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[pos_dst] = RGBA8((videobuf_16[pos_src]&0xF800)>>8,(videobuf_16[pos_src]&0x07E0)>>3, (videobuf_16[pos_src]&0x001F)<<3,0xff);
+						pos_dst++;
+						pos_src++;
+					}
+					pos_dst = pos_dst - x + width;
+					pos_src = pos_src - x + this->info.current_w;
+				}
+
+				break;
+			case 8:
+				for (y=0; y<((height< this->info.current_h)?height:this->info.current_h); y++)//Access the buffer linearly.
+				{
+					for (x=0; x<((width < this->info.current_w)?width:this->info.current_w); x++)
+					{
+						framebuf[pos_dst] = switch_palette[videobuf[pos_src]];
+						pos_dst++;
+						pos_src++;
+					}
+					pos_dst = pos_dst - x + width;
+					pos_src = pos_src - x + this->info.current_w;
+				}
+				break;
+			default:
+				break;
+		}
+
+	}
+	
+	gfxFlushBuffers();
+	gfxSwapBuffers();
+	gfxWaitForVsync();
+
+	return (0);
+}
diff --git a/src/video/switch/SDL_switchvideo.h b/src/video/switch/SDL_switchvideo.h
new file mode 100644
index 000000000..6193b1359
--- /dev/null
+++ b/src/video/switch/SDL_switchvideo.h
@@ -0,0 +1,44 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/  
+#include "SDL_config.h"
+
+#ifndef _SDL_switchvideo_h
+#define _SDL_switchvideo_h
+
+#include "../SDL_sysvideo.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *this
+
+
+/* Private display data */
+
+struct SDL_PrivateVideoData {
+    int w, h;
+    int pw, ph; // phisical framebuffer dimensions
+    int bpp;
+    void *buffer;
+	unsigned int flags; // backup of create device flags
+	int clearbuffer; // number of full hw buffer to clear at startup and after toggling fullscreen (and maybe other situations in future)
+};
+
+#endif /* _SDL_nullvideo_h */
